Pawtimation CRM is currently functional but still uses an in-memory store (store.js).
Your job is to introduce proper production infrastructure without altering any product behaviour, API contracts, or frontend components.

Everything must continue working exactly as before.

This upgrade is strictly infrastructure only:
	‚Ä¢	Postgres
	‚Ä¢	Email delivery
	‚Ä¢	Stripe payments
	‚Ä¢	Environment/security

Do NOT change any functional flow:
Admin, Staff, Client, Bookings, Jobs, Invoices, PDF, Calendars, Services ‚Äî all must remain identical.

‚∏ª

============================================

A. Postgres Migration (P0 ‚Äì Highest Priority)

============================================

1. Database configuration

Implement Postgres support with the following rules:
	‚Ä¢	A DATABASE_URL environment variable will be provided.
	‚Ä¢	App must fail fast at startup if DATABASE_URL is missing.
	‚Ä¢	All data must be stored in Postgres, not in-memory.

2. Schema design

Design tables that directly reflect the existing in-memory data model (repo.js + store.js):

Tables required (minimum):
	‚Ä¢	businesses
	‚Ä¢	users (role: ADMIN, STAFF, CLIENT; businessId; crmClientId where relevant)
	‚Ä¢	clients
	‚Ä¢	dogs
	‚Ä¢	services
	‚Ä¢	jobs (current booking entity)
	‚Ä¢	recurring_jobs
	‚Ä¢	invoices
	‚Ä¢	invoice_items
	‚Ä¢	availability (or weekly availability)
	‚Ä¢	staff_services (pivot table)
	‚Ä¢	messages
	‚Ä¢	cancellations if applicable
	‚Ä¢	Any other entities currently represented inside the in-memory object.

Schema must include:
	‚Ä¢	Correct foreign keys (businessId, clientId, staffId, serviceId)
	‚Ä¢	Indexes on:
	‚Ä¢	businessId
	‚Ä¢	staffId + start
	‚Ä¢	status
	‚Ä¢	clientId (jobs/invoices)

3. Repo migration

Refactor repo.js so that:
	‚Ä¢	All public function signatures remain identical.
	‚Ä¢	No route or frontend needs to change.
	‚Ä¢	All functions read/write to Postgres instead of the in-memory db.
	‚Ä¢	All returned data shapes must remain EXACTLY the same.

This is crucial:
The frontend must not notice the migration.

4. Demo data
	‚Ä¢	Keep the demo seeding, but write directly into Postgres.
	‚Ä¢	Only seed if the tables are empty.
	‚Ä¢	On server restart, all data must persist.

5. Acceptance criteria

The full end-to-end flow must work identically as today:
	‚Ä¢	Admin login
	‚Ä¢	Create clients/dogs/services/staff
	‚Ä¢	Create and approve bookings
	‚Ä¢	Staff assignment
	‚Ä¢	Job completion ‚Üí pending invoice items
	‚Ä¢	Invoice generation + PDF
	‚Ä¢	Mark as paid
	‚Ä¢	Restart server ‚Üí ALL data still exists

No API shapes, names, or behaviour may change.

‚∏ª

============================================

B. Real Email Delivery (P0)

============================================

1. Config

Expect these env vars:
	‚Ä¢	EMAIL_PROVIDER
	‚Ä¢	SENDGRID_API_KEY
	‚Ä¢	EMAIL_FROM

If email config is missing ‚Üí log and skip, but never break app logic.

2. Central email helper

Create emailService with a single minimal function:
	‚Ä¢	sendEmail({ to, subject, html, text })

It should:
	‚Ä¢	use the selected provider
	‚Ä¢	log success/failure
	‚Ä¢	never throw unhandled errors

3. Trigger emails on key events

Wire email sending (using existing data only) into:
	‚Ä¢	New client booking request ‚Üí notify business
	‚Ä¢	Booking approved ‚Üí notify client
	‚Ä¢	Booking cancelled ‚Üí notify client
	‚Ä¢	Invoice generated ‚Üí send invoice link or PDF to client

Templates: minimal + branded (business name, colors, logo if available)

4. Acceptance criteria
	‚Ä¢	Correct emails send when env vars exist
	‚Ä¢	If env vars missing ‚Üí logs warning, continues execution
	‚Ä¢	No frontend changes required

‚∏ª

============================================

C. Stripe Payments (P0)

============================================

1. Config

Expect:
	‚Ä¢	STRIPE_SECRET_KEY
	‚Ä¢	STRIPE_WEBHOOK_SECRET
	‚Ä¢	FRONTEND_BASE_URL

Stripe should be in test mode.

2. Backend integration

Implement:
	‚Ä¢	Endpoint to create a PaymentIntent OR Checkout Session for an invoice:
	‚Ä¢	Amount = invoice.total
	‚Ä¢	Currency = business finance settings (fallback GBP)
	‚Ä¢	Metadata must include invoiceId, clientId, businessId
	‚Ä¢	Webhook handler:
	‚Ä¢	Verify signature using STRIPE_WEBHOOK_SECRET
	‚Ä¢	On successful payment:
	‚Ä¢	Lookup invoice from metadata
	‚Ä¢	Mark it PAID
	‚Ä¢	Set paidAt timestamp
	‚Ä¢	Trigger any revenue/stat refresh logic currently used internally

Webhooks MUST work even if the user closes the browser after paying.

3. Frontend handling (minimal)

Do NOT redesign anything.

Add a single action:
	‚Ä¢	‚ÄúPay Now‚Äù (or use existing button)
	‚Ä¢	Call backend to create payment session
	‚Ä¢	Redirect user to Stripe-hosted checkout

After return:
	‚Ä¢	Show simple success/failure message
	‚Ä¢	Rely on webhook to update invoice status for real

4. Acceptance criteria

From a client account:
	‚Ä¢	View invoice
	‚Ä¢	Pay it with Stripe test card
	‚Ä¢	Invoice becomes PAID via webhook
	‚Ä¢	Revenue dashboards update accordingly
	‚Ä¢	Manual ‚ÄúMark as paid‚Äù remains functional

‚∏ª

============================================

D. Environment & Security Hardening (P0)

============================================

1. Environment

Require the following env vars at startup:
	‚Ä¢	DATABASE_URL
	‚Ä¢	JWT_SECRET
	‚Ä¢	STRIPE_SECRET_KEY
	‚Ä¢	STRIPE_WEBHOOK_SECRET
	‚Ä¢	SENDGRID_API_KEY (optional)
	‚Ä¢	EMAIL_FROM (optional)

If critical env vars missing ‚Üí fail fast.

2. Rate limiting

Add basic rate limiting to:
	‚Ä¢	Login endpoints
	‚Ä¢	Any unauthenticated/public routes

3. Input validation

Add minimal schema validation (Zod or similar) to:
	‚Ä¢	Authentication
	‚Ä¢	Booking creation/update
	‚Ä¢	Invoice generation

Validation must return clean 400-level responses, not 500 errors.

4. CORS

Production CORS must restrict to the correct frontend origin, not *.

5. Acceptance criteria
	‚Ä¢	App refuses to start without critical secrets
	‚Ä¢	Login is rate-limited
	‚Ä¢	Invalid data ‚Üí clean validation errors
	‚Ä¢	CORS correctly locked down

‚∏ª

============================================

E. DO NOT CHANGE ANY BEHAVIOUR

============================================

Replit must NOT:
	‚Ä¢	Change any API route name or return shape
	‚Ä¢	Change the booking lifecycle
	‚Ä¢	Change calendars, staff flows, client flows
	‚Ä¢	Change how jobs, invoices, PDFs, or services work
	‚Ä¢	Remove or rename demo accounts
	‚Ä¢	Break any existing frontend code

This upgrade is backend-only infrastructure, not product logic.

‚∏ª

üéØ Final instruction

Return only when:
	‚Ä¢	Postgres is implemented
	‚Ä¢	Email works
	‚Ä¢	Stripe works
	‚Ä¢	Security is hardened
	‚Ä¢	All existing flows remain 100% unchanged
	‚Ä¢	All end-to-end tests pass
	‚Ä¢	After server restart, all data persists