1️⃣ store.js – new CRM-oriented data model

Replace the entire contents of store.js with this:

// store.js
// Central in-memory store for the Pawtimation CRM (multi-business, staff, clients, dogs, jobs).

export const db = {
  // Core CRM entities
  businesses: {},    // { [businessId]: { id, name, ownerUserId, settings } }
  users: {},         // { [userId]: { id, businessId, role: 'ADMIN'|'STAFF', name, email, phone } }
  clients: {},       // { [clientId]: { id, businessId, name, email, phone, address, notes, dogIds: [] } }
  dogs: {},          // { [dogId]: { id, clientId, name, breed, age, behaviour, notes } }
  services: {},      // { [serviceId]: { id, businessId, name, durationMinutes, priceCents, active } }
  jobs: {},          // { [jobId]: { ...see repo.createJob } }
  availability: {},  // { [staffId]: [ { day: 'MON', start: '09:00', end: '17:00' }, ... ] }
  invoices: {},      // { [invoiceId]: { id, jobId, businessId, clientId, amountCents, status, createdAt, paidAt } }
  recurringJobs: {}, // { [recurringId]: { id, businessId, clientId, staffId, serviceId, rule, active } }
  reports: {},       // { [businessId]: { ...aggregated metrics... } }

  // Legacy / transitional structures (kept to avoid hard crashes while we refactor the UI & routes).
  // You can delete these once the rest of the app is fully migrated to the CRM model.
  usersLegacy: {},     // not used – placeholder if older code references it
  pets: {},            // old pet store – use `dogs` going forward
  sitters: {},         // old sitter store – use `users` with role 'STAFF'
  invites: {},         // legacy invite flow – likely unused in CRM
  bookings: {},        // legacy bookings – we mirror jobs into here for now
  updates: {},         // legacy booking updates / feeds – can be re-used as job notes
  agreements: {},      // legacy sitter agreements – probably safe to remove later
  cancellations: {}    // cancellation records – still useful for CRM reporting
};

This gives you a clean CRM shape:
	•	multiple businesses
	•	staff
	•	clients
	•	dogs
	•	services
	•	jobs
	•	invoices
	•	availability

…and still contains legacy keys so existing code won’t immediately blow up.

⸻

2️⃣ repo.js – new CRM repository API (with legacy shims)

Replace the entire contents of repo.js with this:

// repo.js
// Repository layer for Pawtimation CRM.
// Multi-business, staff, clients, dogs, services, jobs, invoices, availability.
// Includes legacy-compatible methods so existing code can still run while you pivot.

import { db } from './store.js';
import { nid } from './utils.js';

const isoNow = () => new Date().toISOString();

/* -------------------------------------------------------------------------- */
/*  BUSINESS                                                                  */
/* -------------------------------------------------------------------------- */

async function createBusiness(data) {
  const id = data.id || ('biz_' + nid());
  const biz = {
    id,
    name: data.name || 'Untitled Business',
    ownerUserId: data.ownerUserId || null,
    settings: data.settings || {
      currency: 'gbp',
      invoicePrefix: 'INV',
      brandingColor: '#16a34a',
      defaultServicesCreated: false
    }
  };
  db.businesses[id] = biz;
  return biz;
}

async function getBusiness(id) {
  return db.businesses[id] || null;
}

async function updateBusiness(id, patch) {
  if (!db.businesses[id]) return null;
  db.businesses[id] = { ...db.businesses[id], ...patch };
  return db.businesses[id];
}

/* -------------------------------------------------------------------------- */
/*  USERS (ADMIN + STAFF)                                                     */
/* -------------------------------------------------------------------------- */

async function createUser(data) {
  const id = data.id || ('u_' + nid());
  const user = {
    id,
    businessId: data.businessId || null,
    role: data.role || 'STAFF', // 'ADMIN' | 'STAFF'
    name: data.name || '',
    email: data.email || '',
    phone: data.phone || '',
    active: data.active !== false
  };
  db.users[id] = user;

  // Legacy mapping for "sitters" (temporary)
  if (user.role === 'STAFF') {
    db.sitters[id] = { id, userId: id, name: user.name, email: user.email };
  }

  return user;
}

async function getUser(id) {
  return db.users[id] || null;
}

async function listUsersByBusiness(businessId) {
  return Object.values(db.users).filter(u => u.businessId === businessId);
}

async function listStaffByBusiness(businessId) {
  return Object.values(db.users).filter(
    u => u.businessId === businessId && u.role === 'STAFF'
  );
}

/* -------------------------------------------------------------------------- */
/*  CLIENTS                                                                   */
/* -------------------------------------------------------------------------- */

async function createClient(data) {
  const id = data.id || ('c_' + nid());
  const client = {
    id,
    businessId: data.businessId,
    name: data.name || '',
    email: data.email || '',
    phone: data.phone || '',
    address: data.address || '',
    notes: data.notes || '',
    dogIds: data.dogIds || []
  };
  db.clients[id] = client;
  return client;
}

async function getClient(id) {
  return db.clients[id] || null;
}

async function listClientsByBusiness(businessId) {
  return Object.values(db.clients).filter(c => c.businessId === businessId);
}

/* -------------------------------------------------------------------------- */
/*  DOGS (formerly pets)                                                      */
/* -------------------------------------------------------------------------- */

async function createDog(data) {
  const id = data.id || ('dog_' + nid());
  const dog = {
    id,
    clientId: data.clientId,
    name: data.name || '',
    breed: data.breed || '',
    age: data.age || null,
    behaviour: data.behaviour || {},
    notes: data.notes || ''
  };
  db.dogs[id] = dog;

  // update client.dogIds
  if (dog.clientId && db.clients[dog.clientId]) {
    const c = db.clients[dog.clientId];
    if (!c.dogIds.includes(id)) c.dogIds.push(id);
  }

  // Legacy pets mirror
  db.pets[id] = { id, ...dog };

  return dog;
}

async function getDog(id) {
  return db.dogs[id] || null;
}

async function listDogsByClient(clientId) {
  return Object.values(db.dogs).filter(d => d.clientId === clientId);
}

/* -------------------------------------------------------------------------- */
/*  SERVICES                                                                  */
/* -------------------------------------------------------------------------- */

async function createService(data) {
  const id = data.id || ('svc_' + nid());
  const svc = {
    id,
    businessId: data.businessId,
    name: data.name || 'Service',
    durationMinutes: data.durationMinutes ?? 30,
    priceCents: data.priceCents ?? 0,
    active: data.active !== false
  };
  db.services[id] = svc;
  return svc;
}

async function getService(id) {
  return db.services[id] || null;
}

async function listServicesByBusiness(businessId) {
  return Object.values(db.services).filter(s => s.businessId === businessId);
}

/* -------------------------------------------------------------------------- */
/*  AVAILABILITY                                                              */
/* -------------------------------------------------------------------------- */

async function setStaffAvailability(staffId, slots) {
  // slots: [ { day:'MON', start:'09:00', end:'17:00' }, ... ]
  db.availability[staffId] = Array.isArray(slots) ? slots : [];
  return db.availability[staffId];
}

async function getStaffAvailability(staffId) {
  return db.availability[staffId] || [];
}

/* -------------------------------------------------------------------------- */
/*  JOBS (core CRM "booking" entity)                                          */
/* -------------------------------------------------------------------------- */

// Helper: naive overlap check in milliseconds
function rangesOverlap(startA, endA, startB, endB) {
  const aStart = new Date(startA).getTime();
  const aEnd = new Date(endA).getTime();
  const bStart = new Date(startB).getTime();
  const bEnd = new Date(endB).getTime();
  return aStart < bEnd && bStart < aEnd;
}

async function createJob(data) {
  const id = data.id || ('job_' + nid());
  const svc = data.serviceId ? db.services[data.serviceId] : null;

  const start = data.start;
  let end = data.end;

  if (!end && svc && svc.durationMinutes) {
    const ms = new Date(start).getTime() + svc.durationMinutes * 60 * 1000;
    end = new Date(ms).toISOString();
  }

  const job = {
    id,
    businessId: data.businessId,
    clientId: data.clientId,
    dogIds: data.dogIds || [],
    staffId: data.staffId || null,
    serviceId: data.serviceId || null,
    start,
    end,
    status: data.status || 'PENDING', // 'PENDING' | 'APPROVED' | 'COMPLETE' | 'CANCELLED'
    priceCents:
      data.priceCents ??
      (svc && typeof svc.priceCents === 'number' ? svc.priceCents : 0),
    notes: data.notes || '',
    createdAt: isoNow(),
    updatedAt: isoNow()
  };

  db.jobs[id] = job;

  // Mirror into legacy bookings so existing code that reads db.bookings still sees something.
  db.bookings[id] = job;

  return job;
}

async function getJob(id) {
  return db.jobs[id] || null;
}

async function updateJob(id, patch) {
  if (!db.jobs[id]) return null;
  db.jobs[id] = { ...db.jobs[id], ...patch, updatedAt: isoNow() };
  db.bookings[id] = db.jobs[id]; // keep legacy mirror in sync
  return db.jobs[id];
}

async function listJobsByBusiness(businessId) {
  return Object.values(db.jobs).filter(j => j.businessId === businessId);
}

async function listJobsByStaffAndRange(staffId, startIso, endIso) {
  return Object.values(db.jobs).filter(j => {
    if (j.staffId !== staffId) return false;
    if (!j.start || !j.end) return false;
    return rangesOverlap(j.start, j.end, startIso, endIso);
  });
}

async function assignStaffToJob(jobId, staffId) {
  if (!db.jobs[jobId]) return null;
  db.jobs[jobId].staffId = staffId;
  db.jobs[jobId].updatedAt = isoNow();
  db.bookings[jobId] = db.jobs[jobId];
  return db.jobs[jobId];
}

async function setJobStatus(jobId, status) {
  if (!db.jobs[jobId]) return null;
  db.jobs[jobId].status = status;
  db.jobs[jobId].updatedAt = isoNow();
  db.bookings[jobId] = db.jobs[jobId];
  return db.jobs[jobId];
}

/* -------------------------------------------------------------------------- */
/*  SIMPLE AVAILABILITY CHECK (for future manager view)                       */
/* -------------------------------------------------------------------------- */

async function listAvailableStaffForSlot(businessId, startIso, endIso) {
  const staff = await listStaffByBusiness(businessId);
  const result = [];

  for (const s of staff) {
    const jobs = await listJobsByStaffAndRange(s.id, startIso, endIso);
    const isFree = jobs.length === 0;
    result.push({ staff: s, isFree, conflictingJobs: jobs });
  }

  return result;
}

/* -------------------------------------------------------------------------- */
/*  INVOICES                                                                  */
/* -------------------------------------------------------------------------- */

async function createInvoice(data) {
  const id = data.id || ('inv_' + nid());
  const inv = {
    id,
    businessId: data.businessId,
    clientId: data.clientId,
    jobId: data.jobId || null,
    amountCents: data.amountCents || 0,
    status: data.status || 'UNPAID', // 'UNPAID' | 'PAID'
    createdAt: isoNow(),
    paidAt: data.paidAt || null,
    meta: data.meta || {}
  };
  db.invoices[id] = inv;
  return inv;
}

async function getInvoice(id) {
  return db.invoices[id] || null;
}

async function markInvoicePaid(id) {
  if (!db.invoices[id]) return null;
  db.invoices[id].status = 'PAID';
  db.invoices[id].paidAt = isoNow();
  return db.invoices[id];
}

async function listInvoicesByBusiness(businessId) {
  return Object.values(db.invoices).filter(i => i.businessId === businessId);
}

/* -------------------------------------------------------------------------- */
/*  CANCELLATIONS (still useful for CRM)                                      */
/* -------------------------------------------------------------------------- */

async function recordCancellation(evt) {
  const id = 'cx_' + nid();
  db.cancellations[id] = {
    id,
    ...evt,
    occurredAt: isoNow()
  };
  return db.cancellations[id];
}

/* -------------------------------------------------------------------------- */
/*  LEGACY-COMPATIBILITY METHODS (TEMPORARY SHIMS)                            */
/* -------------------------------------------------------------------------- */

// You can delete this whole block once the rest of the app no longer relies
// on the old booking/sitter APIs.

async function createInvite(data) {
  const id = nid();
  db.invites[id] = { id, ...data };
  return db.invites[id];
}

async function getInvite(id) {
  return db.invites[id] || null;
}

async function setInviteStatus(id, status) {
  if (db.invites[id]) db.invites[id].status = status;
  return db.invites[id] || null;
}

// Legacy booking API mapped to jobs
async function createBooking(data) {
  return createJob(data);
}

async function getBooking(id) {
  return getJob(id);
}

// Legacy updates/feed – you can later refactor this into "job notes" / "walk reports".
async function addUpdate(jobId, upd) {
  db.updates[jobId] = db.updates[jobId] || [];
  db.updates[jobId].push(upd);
  return upd;
}

async function getFeed(jobId) {
  return {
    booking: db.jobs[jobId] || null,
    updates: db.updates[jobId] || []
  };
}

// Legacy sitter helpers mapped to staff (users with role STAFF)
async function getSitterById(id) {
  return db.sitters[id] || null;
}

async function upsertSitter(p) {
  const id = p.id || p.userId || ('u_' + nid());
  const user = db.users[id] || {
    id,
    businessId: p.businessId || null,
    role: 'STAFF',
    name: p.name || '',
    email: p.email || ''
  };
  db.users[id] = { ...user, ...p, role: 'STAFF' };
  db.sitters[id] = { id, ...db.users[id] };
  return db.sitters[id];
}

async function updateSitterTier(id, tier) {
  if (!db.sitters[id]) return null;
  db.sitters[id].tier = tier;
  return db.sitters[id];
}

async function getReferencesBySitterId() {
  return [];
}

async function getSitterAgreements() {
  return [];
}

async function addSitterAgreement(a) {
  const id = a.id || ('agr_' + nid());
  db.agreements[id] = { id, ...a };
  return db.agreements[id];
}

// Legacy helpers used by cancellationRoutes, payments etc.
async function setBookingStatus(id, status) {
  return setJobStatus(id, status);
}

async function markBookingPaid(id, escrowId) {
  if (!db.jobs[id]) return null;
  db.jobs[id].escrowId = escrowId;
  db.jobs[id].updatedAt = isoNow();
  db.bookings[id] = db.jobs[id];
  return db.jobs[id];
}

/* -------------------------------------------------------------------------- */
/*  EXPORT                                                                    */
/* -------------------------------------------------------------------------- */

export const repo = {
  // New CRM-first API
  createBusiness,
  getBusiness,
  updateBusiness,

  createUser,
  getUser,
  listUsersByBusiness,
  listStaffByBusiness,

  createClient,
  getClient,
  listClientsByBusiness,

  createDog,
  getDog,
  listDogsByClient,

  createService,
  getService,
  listServicesByBusiness,

  setStaffAvailability,
  getStaffAvailability,

  createJob,
  getJob,
  updateJob,
  listJobsByBusiness,
  listJobsByStaffAndRange,
  assignStaffToJob,
  setJobStatus,
  listAvailableStaffForSlot,

  createInvoice,
  getInvoice,
  markInvoicePaid,
  listInvoicesByBusiness,

  recordCancellation,

  // Legacy shims (safe to remove later when unused)
  createInvite,
  getInvite,
  setInviteStatus,
  createBooking,
  getBooking,
  addUpdate,
  getFeed,
  getSitterById,
  upsertSitter,
  updateSitterTier,
  getReferencesBySitterId,
  getSitterAgreements,
  addSitterAgreement,
  setBookingStatus,
  markBookingPaid
};


